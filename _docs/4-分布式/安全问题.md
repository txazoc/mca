### 安全问题

#### HTTPS

#### XSS

> 跨站脚本，Cross-Site Scripting

#### CSRF

> 跨站请求伪造，Cross-Site Request Forgery，攻击者诱导受害者进入第三方网站，在第三方网站中，`向被攻击网站发送跨站请求`

* CSRF原理: `冒用受害者的登录凭证`
* CSRF特点: 无法跨域，不能获取到Cookie

**CSRF防护措施**

* 同源检测: Origin、Referer
* CSRF Token: 所有请求都要求携带一个CSRF攻击者无法获取到的Token
    * Redis存储Token
    * Token由uid、时间戳、随机数加密生成，无需后端存储
* 双重Cookie验证
* 防止网站被利用: 严格管理上传接口内容，包括HTML内容、图片、链接

#### SQL注入

> 用户输入的数据被植入SQL代码，例如`or 1 = 1`、`union select * from table`等

**SQL注入方式**: get注入、post注入、Cookie注入

**SQL注入防护**

* 使用MyBatis框架，SQL预编译，`#{}`
* 使用`${}`的参数，过滤MySQL关键词，严格校验数据类型

#### 后端接口防刷

##### 防机器暴力登录

> 防暴力破解账号密码，一个账号N多密码，N多账号和密码

* ip登录次数频控
* ip黑名单
* 账号登录次数限制
* 账号和常用登录ip绑定，新的ip进行验证码验证
* 验证码验证
* 密码最少6位，包含字母和数字

##### 图形验证码

> 账号密码登录方式进行验证码验证

* 图形验证码框架: `Google Captcha`
* 进入登录页面，后端生成`验证码`保存到Session，同时通过`Google Captcha`生成验证码图片返回给登录页面
* 登录时，后端先校验提交的验证码和Session中的验证码是否一致，不一致则返回验证码错误

`注:`: 验证码图片尽量复杂，防止机器自动破解

##### 短信验证码

> 使用手机验证码登录

* 进入登录页面，填写手机号，点击发送验证码
* 后端生成4到6位数字验证码，保存到Session，然后调用短信通道发送验证码短信
* 用户收到短信，填写验证码，点击登录
* 登录时，后端先校验提交的验证码和Session中的验证码是否一致，不一致则返回验证码错误

`注`: 防止短信被恶意盗刷

##### 接口防刷

> 防止接口被恶意调用

* 频控
* 黑名单: ip、设备、用户
* 并发控制: 防止薅羊毛
* 加签/验签

##### 请求/响应加密

* Https
* 自定义数据协议

#### 总结

* ip维度: 频控、黑名单
* 用户维度: 频控、黑名单
* 验证码: 图形验证码、短信验证码、邮件验证码
* 限流: 接口、发短信
* 加签/验签: 对称加密/解密、消息摘要算法(MD5、SHA)、加盐
* 大数据风控
